# DMA控制器

* [返回上层目录](../io-and-bus.md)

# DMA介绍

问题：

> DMA可以直接从内存读取数据，那它到底是个硬件设备，还是一个软件算法？或者仅仅是个什么配置？

回答：

用最直观的话回答

- DMA 是硬件。准确说是芯片/板子上的“DMA 控制器/引擎”，能在不占用 CPU 的情况下，把一大块数据从内存搬到另一个地方（或从设备搬到内存）。

- 软件的作用是“配置并启动 DMA”：通过驱动/寄存器告诉 DMA 源地址、目标地址、长度、对齐方式等，然后硬件自己搬；搬完会发中断/状态给软件。

- 不是算法/库，也不只是“一个配置”。它是硬件功能，软件只是“下指令”。

它怎么工作（一步步）

1) CPU/驱动把“源物理地址、传输长度、格式/对齐、控制位”写进 DMA 控制器的寄存器（或提交描述符）。

2) CPU写“启动位” → DMA 硬件开始自己搬运数据。

3) 搬完后 DMA 置位“完成标志”/发中断，CPU再继续后续逻辑（比如启动推理、处理结果）。

为什么要用 DMA

- 省 CPU：CPU不用循环拷贝每个字节，可去做别的实时任务。

- 快/可预测：硬件总线直连搬运，吞吐高、延迟稳定，更符合实时系统需求。

- 少拷贝：典型路径是“设备直接从指定内存拉数据”，避免多次中间拷贝。

放到代码里理解

- 你看到的寄存器写入就是在“配置 DMA”：

- 源地址用的是固定物理区 0x31000000（设备可见的 DDR）。

- dev->writeRelativeReg(...) 这些就是写 DMA/预处理模块的寄存器，最后写启动位让 DMA 开始读图。

- 这之前确实有一条 memcpy((void*)0x32000000, mat_data, size_tmp)：这是把 OpenCV 读到的“普通内存”先摆到“设备能直接读”的物理区域。

- 若相机/解码器能“直接 DMA 到 0x32000000（或环形缓冲）”，这次 memcpy 也能省掉，形成真正端到端的零拷路径。

小对比：memcpy vs DMA

- memcpy：CPU指令在拷，CPU被占用。

- DMA：硬件控制器在拷，CPU只负责下命令，不参与大搬运。

一个比喻

- CPU像店员亲自搬货（memcpy）→ 人累还慢。

- DMA像传送带（硬件）自动搬运，店员只按按钮配置路径（软件配置寄存器），自己去干别的活。

这就是为什么“喂一张图片给模型”在硬件推理场景里会牵涉到 DMA：需要把数据摆到“设备可读的地方”，并用硬件传送带高效搬进去，保障吞吐与实时性。

# DMA配置

问题：

> > dev->writeRelativeReg(...) 这些就是写 DMA/预处理模块的寄存器，最后写启动位让 DMA 开始读图。
>
> DMA搬运为什么要写/配置寄存器呢？直接让它读对应地址的内容不就行了吗

回答：

不是“它自己去读一读就行了”的问题，DMA 是硬件总线主控（bus master），每一次搬运都必须被精确告知“从哪儿读、读多少、怎么读、什么时候开始”。这些参数只能通过寄存器（或描述符表）告诉它。

- 为什么要配寄存器

  - 明确参数：源物理地址、目标地址/外设FIFO、长度、步幅/对齐、突发大小、通道数、数据格式、端序等。

  - 明确时序：何时开始/停止、是否产生中断、是否循环、是否链式传输。

  - 安全与仲裁：DMA要成为总线主控访问内存，必须在受控前提下运行，不能“擅自乱读内存”。寄存器接口是权限和配置的边界。

  - 可重用：每一帧/每一次传输的地址和长度都变，必须能被软件动态下发。

- 代码里每一项大概在说什么

  - 源地址：dev->writeRelativeReg(reg_base_preset + 0x4, 0x31000000);

  - 传输长度：reg_base_preset + 0x8

  - 末包偏移/打包信息（像素对齐）：reg_base_preset + 0xC

  - 通道数（RGB/BGR等）：reg_base_preset + 0x10

  - 控制/清零等：reg_base_preset + 0x1C、+ 0x20

  - 启动位（真正“开车”的按钮）：dev->writeRelativeReg(reg_base_preset, 1);

- “直接让它读地址”的问题

  - 读哪个地址？多长？一维还是二维（图像常需 pitch/stride）？按字节/半字/突发？这些都需要显式配置。

  - 总线权限与一致性：必须确保是“设备可见的物理地址”，且按要求对齐/刷缓存；这些都要配合配置完成。

  - 即便是描述符模式（scatter-gather），也要先把“描述符基址+使能位”写进寄存器，DMA才知道去哪里取描述符。

- 类比
  - DMA像一条可编程的传送带。你得告诉它“起点、终点、长度、打包方式、什么时候开”，它才会搬；寄存器就是“控制面板”。

结论：配置寄存器是告诉硬件“这次该怎么搬”的唯一标准途径；没有这些配置，DMA既不知道从哪儿读，也不知道读多少，更无法保证时序和安全。

补充说明：

- 寄存器为什么必须配：DMA 是硬件“传送带”，每次都要被明确告知“从哪儿读、读多少、如何对齐/打包、何时开始”，这些只能通过寄存器/描述符告诉它；不是“自动去读某个地址就行”。

- 缓存一致性与对齐：源地址必须是设备可见的物理内存，且满足 IP 要求的对齐（你的代码里对齐到 64B）；必要时在 memcpy 后做 cache flush，避免 DMA 读到旧数据。

- 精确字段语义：上面是通用硬件含义；具体 bit 含义要参考这块 ImageMake/DMA IP 的寄存器手册，但功能范畴就是“源地址/长度/尾包/通道/控制/启动”。

DMA寄存器配置举例

```c++
uint64_t reg_base_preset = 0x100a00000;  // 设备寄存器基址

// 把 rgbMat.data 这帧图拷到设备可见的物理内存（PS DDR 的固定地址）。
// 本工程里把 0x32000000 当成预留的设备可见物理缓冲区，CPU 先把图像拷过去，
// 随后由设备侧的 DMA 引擎按你写入的寄存器参数从这个地址“拉取”数据进入推理流水线。
memcpy((void*)0x31000000, mat_data, size_tmp);  // 把CPU侧图像搬到设备可见的物理区
// 1) OpenCV 把图读到 host 普通内存。
// 2) CPU memcpy → 设备可见物理缓冲（0x31000000，PS DDR 的固定区）。
// 3) 硬件 DMA 从该物理缓冲“拉取”数据进入 Image-Make/预处理/推理流水线（非 CPU 循环拷）。
// 4) forward() 在设备侧直接消费输入缓冲。
// 之前说“去掉中间拷贝与 CPU 负担”，指的是避免“再把 host 张量传给 runtime 再做一遍
//  host→device 上传”的那类额外拷贝，以及避免由 CPU 逐字节喂硬件；这里保留的一次 memcpy 
// 是“把任意来源的数据摆到设备可见区”的必要上游拷贝。之后的大搬运由 DMA 完成。
// 
// 更进一步的“零拷路径”通常是：摄像头/PL 直接 DMA 到 0x32000000（或环形缓冲），这样就
// 连这次 memcpy 也省掉。你文件后半段用相机寄存器的那套流程就是往这个方向走的。

// 0x32000000 必须是设备可访问的物理内存窗口（BSP/硬件约定的映射），且满足对齐要求（代码里对齐到64B）。
// 注意缓存一致性：该区域应配置为不可缓存，或在 memcpy 后做 cache flush，否则 DMA 读到的可能是旧数据。
// 量产建议用驱动/SDK 的 DMA 内存分配接口或环形缓冲，少用硬编码地址；有直连摄像头时可让摄像头直接 DMA 到该区域，省掉这次 memcpy。

uint32_t image_rddr_base = 0x31000000;   // ps ddr数据基址，源物理地址


// 写入设备寄存器，最后下发“启动”位，触发DMA一次性把这帧作为网络输入。
// 整体图景：reg_base_preset 是这块“图像取流/预处理（ImageMake）+ DMA”硬件模块
//   的寄存器基址。每一条 writeRelativeReg(base + offset, value) 都是在配置
//   该模块的一个寄存器字段，最后写“启动位”让硬件开始从内存把这一帧搬进推理流水线。
// 配置源地址
// 把“源物理地址”写给硬件，让 DMA 知道从哪里读图像数据。
dev->writeRelativeReg(reg_base_preset + 0x4, image_make_rddr_base);
// 配置搬运长度，传输总字节数
// image_make_rlen 是根据图像宽高/通道和像素打包规则算出来的本次总传输长度。
dev->writeRelativeReg(reg_base_preset + 0x8, image_make_rlen);
// 配置末包偏移（last shift）
// image_make_last_sft 描述最后一小段未满对齐包的“尾部偏移/残量”，便于 DMA 在像素打包不是整齐字节边界时也能正确收尾。
dev->writeRelativeReg(reg_base_preset + 0xC, image_make_last_sft);
// 配置通道数
// 告诉硬件这帧的通道布局（如 1=灰度，3=RGB），以便正确步进/解包。
dev->writeRelativeReg(reg_base_preset + 0x10, image_make->channel);
// 其他控制位
// 其他控制位（置 1）
// 常见用于使能子模块、清状态、选择一次性/循环模式等初始化控制。
// 具体语义要以该 IP 的手册为准，但这里的作用是把控制位配置到“可启动”的状态。
dev->writeRelativeReg(reg_base_preset + 0x1C, 1);
// 其他控制位（清 0）
// 一般是清某个模式/状态或复位某个指针，确保这次搬运按期望方式进行。
dev->writeRelativeReg(reg_base_preset + 0x20, 0);
// 写启动位，触发DMA
// 往“启动寄存器”写 1，正式触发 DMA 开始读你配置的“源地址/长度”等，把本帧推到设备侧输入缓冲/预处理通道里。
dev->writeRelativeReg(reg_base_preset, 1);

// DMA会把LS DDR中的数据读到硬件模块（PL 侧）的输入接口/缓冲
// PS DDR 0x31000000（源） → 通过 AXI 总线 → PL 上的 ImageMake/预处理模块的输入 FIFO/
// 寄存器窗口 →（再流入）NPU/加速器的片上 SRAM/BRAM 输入缓冲。
```



# DMA获取数据流程

问题：

> PS DDR，DDR我现在知道是主内存了，但是PS是什么意思？还有个PL，这又是什么意思？

回答：

- PS: Processing System，指芯片里的“处理系统”子域，通常是 ARM 核、缓存、MMU、DDR 控制器以及通用外设所在的那一侧（CPU 世界）。

- PL: Programmable Logic，指“可编程逻辑”子域，通常是 FPGA 逻辑阵列，用来挂载自定义加速器（如 NPU、图像预处理、DMA 引擎等）。

- PS DDR: 由 PS 侧的内存控制器管理的主内存（DDR）。CPU 直接访问；PL 侧的加速器可通过片上 AXI 接口（如 HP/ACP 端口）访问这块内存。

- PL DDR: 有些平台还会在 PL 侧挂独立的 DDR（可选）。加速器大吞吐场景会把中间缓冲放在 PL DDR，减少和 CPU 的总线竞争。

- 在代码/流程里的含义

  - CPU 把图像拷到 PS DDR 的某个物理地址（例如 0x31000000）。

  - PL 侧的 DMA/预处理模块通过 AXI 端口从该物理地址直接取数据进入加速流水线。

  - 因为是跨 PS/PL 访问，需注意物理地址、对齐与缓存一致性（写完需 flush，读前/后需按需要 invalidate）。
